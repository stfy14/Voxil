#version 450 core
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// === СТРУКТУРЫ ===

struct DynamicObject {
    mat4 model;
    mat4 invModel;
    vec4 color;
    vec4 boxMin;
    vec4 boxMax;
};

struct ListNode {
    uint objectID;
    int nextNode;
};

// === БУФЕРЫ ===

// Binding 2: Массив объектов (только чтение)
layout(std430, binding = 2) buffer DynObjects {
    DynamicObject dynObjects[];
};

// Binding 3: Массив узлов списка (запись)
// Используем имя listNodes для надежности
layout(std430, binding = 3) buffer LinkedList {
    ListNode listNodes[];
};

// Binding 1: Текстура-голова (R32I)
layout(binding = 1, r32i) uniform iimage3D uObjectGridHead;

// Binding 4: Атомарный счетчик
layout(binding = 4, offset = 0) uniform atomic_uint uCounter;

// === UNIFORMS ===

uniform int uObjectCount;
uniform vec3 uGridOrigin;
uniform float uGridStep;
uniform int uGridSize;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uObjectCount) return;

    // ID объекта (1-based)
    uint objectID = idx + 1;
    DynamicObject obj = dynObjects[idx];

    // Вычисляем AABB (Axis Aligned Bounding Box)
    vec3 corners[8];
    corners[0] = vec3(obj.boxMin.x, obj.boxMin.y, obj.boxMin.z);
    corners[1] = vec3(obj.boxMax.x, obj.boxMin.y, obj.boxMin.z);
    corners[2] = vec3(obj.boxMin.x, obj.boxMax.y, obj.boxMin.z);
    corners[3] = vec3(obj.boxMax.x, obj.boxMax.y, obj.boxMin.z);
    corners[4] = vec3(obj.boxMin.x, obj.boxMin.y, obj.boxMax.z);
    corners[5] = vec3(obj.boxMax.x, obj.boxMin.y, obj.boxMax.z);
    corners[6] = vec3(obj.boxMin.x, obj.boxMax.y, obj.boxMax.z);
    corners[7] = vec3(obj.boxMax.x, obj.boxMax.y, obj.boxMax.z);

    vec3 worldMin = vec3(1e30);
    vec3 worldMax = vec3(-1e30);

    for(int i=0; i<8; i++) {
        vec3 worldPos = (obj.model * vec4(corners[i], 1.0)).xyz;
        worldMin = min(worldMin, worldPos);
        worldMax = max(worldMax, worldPos);
    }

    // Переводим AABB в координаты сетки
    vec3 gridMinF = (worldMin - uGridOrigin) / uGridStep;
    vec3 gridMaxF = (worldMax - uGridOrigin) / uGridStep;

    // Ограничиваем индексами сетки
    ivec3 minI = ivec3(max(vec3(0), floor(gridMinF)));
    ivec3 maxI = ivec3(min(vec3(uGridSize - 1), floor(gridMaxF)));

    // Заполняем ячейки
    for (int z = minI.z; z <= maxI.z; z++) {
        for (int y = minI.y; y <= maxI.y; y++) {
            for (int x = minI.x; x <= maxI.x; x++) {

                // 1. Атомарно выделяем место в буфере узлов
                uint nodeIndex = atomicCounterIncrement(uCounter);

                // Защита от переполнения буфера (2 млн узлов)
                if (nodeIndex >= 2000000) return;

                // Индекс для хранения в текстуре (1-based, чтобы 0 был null)
                int storedNodeIndex = int(nodeIndex) + 1;

                // 2. Атомарно обновляем голову списка в текстуре
                // imageAtomicExchange возвращает старое значение (которое станет nextNode)
                int oldHead = imageAtomicExchange(uObjectGridHead, ivec3(x, y, z), storedNodeIndex);

                // 3. Записываем данные в узел
                listNodes[nodeIndex].objectID = objectID;
                listNodes[nodeIndex].nextNode = oldHead;
            }
        }
    }
}